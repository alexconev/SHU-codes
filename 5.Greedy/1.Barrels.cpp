/*

Дадени са N бъчви и с известно количество течност A[i] във всяка от тях. 
Всеки две последователни бъчви са свързани с кранчета в долните си краища 
(първата и последната бъчви също са свързани). В началото всички кранчета 
са затворени, а при отварянето на кранче, бъчвите, които свързва си изравняват 
количеството течност. Трябва да се намери минималния брой кранчета, които 
трябва да се отворят, за да се изравни нивото във всички бъчви.

Пример #1
	Вход
	3
	2 2 2
	Изход
	0

Пример #2
	Вход
	4	
	4 3 3 2
	Изход
	1

Пример #3
	Вход
	6
	3 3 3 3 3 2		
	Изход
	5

*/


#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

const double eps = 1e-9; 

int n, a[1024];
double delta[1024];

int LineCheck(int shift){
    int br = 0;
    double sum2 = 0.0;
    for (int i=0; i<n; i++) {  // извърта всички бъчви
        sum2 += delta[(i + shift) % n];  // натрупва разликите
        if (abs(sum2) > eps)
           br++;  // ако не е нула сумата, то трябва да добавим още една бъчва, 
                  // която да се опита да уравновеси съдържанието
    }

    return br;
}

int main() {
    int sum = 0;

    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum += a[i];
    }
    a[n] = a[0];

    double TotalAvg = (double)sum / n;  // средно аритметично

    for (int i = 0; i < n; i++) {
        delta[i] = (double)a[i] - TotalAvg;  // разлики със средната стойност
    }

    int totalBr = 0, br;
    for (int j = 0; j < n; j++) {  // отмества началото и разглеждаме линейния случай
    	br = LineCheck(j);
        if (br != 0 && (totalBr == 0 || totalBr > br))
           totalBr = br; // намиране на минималния ненулев брой на отворени кранчета
    }

    cout << totalBr << endl;

    return 0;
}
