/*

Дадени са две естествени числа p и q (q != 0, p < q; p,q). Да се намери представяне
на дробта p/q във вид на сума:

p/q = 1/a1 + 1/a2 + ... + 1/an,

при което знаменателите да бъдат различни (ai != aj).

Вход: На стандартния вход се въвъеждат 2 числа p,q (p,q < 1000).
Изход: На стандартния изход да се изведат дробите, разделени с интервал

Пример #1:
	Вход:
	3 7

	Изход:
	3 11 231

	3/7 = 1/3 + 1/11 + 1/231
	3/7 = 1/4 + 1/8 + 1/19 + 1/1064

*/

#include <iostream>
using namespace std;

unsigned long long ch,zn;

/* ако q е кратно на p, се извършва съответно съкращение */
void cancel(unsigned long long p, unsigned long long q) {
	if (q % p == 0) {
		q /= p; p = 1;
	}
}

void solve(unsigned long p, unsigned long q) {

	cancel(p, q);

	while (p > 1) {
		/* намира максималната дроб 1/r, 1/r<=p/q */
		unsigned long r;
		r = (q + p) / p;
		cout << "1/" << r <<' ';
		/* изчислява p/q - 1/r */
		p = p * r - q;
		q = q * r;
		cancel(p, q);
	}

	if (p > 0)	cout << "1/" << q << ' ';

	cout << endl;
}

int main(){

	cin >> ch >> zn;
	solve(ch, zn);
	return 0;
}

/*

Анализ:

В конкретната задача търсим произволно решение, отговарящо на условието знаменателите
на намерените дроби да бъдат различни. Да разгледаме следния прост алчен алгоритъм:
На всяка стъпка поредният член в сумата ще бъде максималната дроб, която може да се
добави към текущата сума така, че резултатът да не надвишава p/q (тъй като числителят
е винаги 1, това означава дробта с най-малък знаменател). Например за p/q = 7/9
най-голямата възможна дроб е 1/2. По-нататък трябва да изберем нова дроб 1/a2, така че:
1/2 + 1/a2 < 7/9, т. е. 1/a2 <= 7/9 - 1/2, или 1/a2 <= 5/18.
Най-голямата дроб, отговаряща на това условие, е 1/4, при което получаваме:
1/a3 <= 7/9 - 1/2 - 1/4 = 5/18 - 1/4 = 2/72,
т. е. максималното a3 е 1/36, с което сумирането приключва: 1/2 + 1/4 + 1/36 = 7/9.
Изчисленията в последния пример подсказват каква ще бъде схемата за реализация на алгоритъма:

while (p > 1) {
намира се максималната дроб 1/r, ненадвишаваща p/q;
отпечатва се дробта 1/r;
p/q = p/q - 1/r;
}

Тук трябва да уточним две неща. Първото е как да търсим максималната дроб 1/r,
ненадвишаваща p/q , т. е. минималното r, за което е изпълнено 1/r <= p/q, r => 2, q => 2.
Това е еквивалентно на r => q/p. За да намерим r, можем да извършим делението q/p и да вземем
най-малкото цяло число, не по-малко от q/p. Ще намерим r, като използваме само целочислено
деление: r = (q+p)/p. Разликата p/q - 1/r се пресмята чрез привеждане под общ знаменател.

Така новите стойности за p и q ще бъдат:
p = p*r - q;
q = q*r;

Възможно е след пресмятане на разликата да се получи съкратима дроб. Това ще попречи на
правилната работа на алгоритъма единствено в случая, когато се получи дроб p/q, която може
да се съкрати до 1/x, т. е. q % p == 0. В този случай, ако не се извърши съкращението,
условието p > 1 ще остава изпълнено и търсенето на дроби ще продължава до безкрайност.

*/