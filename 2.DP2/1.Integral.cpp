/*

Да се състави програма, която прочита N числа и М двойки i,j
и отпечатва сумите на елементите от i до j.

Вход
На първия ред на стандартния вход се задава числото N, на
следващия ред се въвеждат N-те числа, на третия
ред се въвежда броя M на двойките числа i,j на следващите
редове има по 1 двойка числа.
	2 <= N < 10^5; 1 <= M < 10^3

Изход
На стандартния изход се отпечатват М реда със сумите.

Пример #1
	Вход
	10
	1 2 3 4 5 6 7 8 9 10
	3
	1 10
	2 9
	3 8

	Изход
	55
	44
	33


*/

#include <iostream>
using namespace std;

int n, m, a[10000];

void solve2(){
	int s,f;
	long long c[10000];

	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
		if(i == 1) c[i] = a[i];
		else c[i] = c[i-1] + a[i];
	}

	cin >> m;
	for(int i = 0; i < m; i++){
		cin >> s >> f;
		cout << c[f] - c[s-1] << endl;
	}
}

void solve(){
	int s,f;

	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}

	cin >> m;
	for(int i = 0; i < m; i++){
		cin >> s >> f;
		long long sum = 0;
		for(int j = s; j <= f; j++){
			sum += a[j];
		}
		cout << sum << endl;
	}
}

int main(){

	solve(); // O(N*M)
	//solve2(); // O(M)

	return 0;
}

/*

Анализ: Тъпото решение на задачата е да правим точно каквото е описано в
условието на задачата - прочитаме числата,
записваме ги и за всеки интервал обхождаме елементите и ги събираме. Този
метод не е оптимизиран понеже
сложността му е О(M*N). Как може да се оптимизира това решение?!

Естествено, че с интергрален масив. Интегралния масив представлява масив
със сумата на досегашните елементи.

I_A[0] = sum(0,0);
I_A[1] = sum(0,1);
I_A[i] = sum(0,i);

Сумата в даден интервал може се получи като от j-тата се извади
(i-1)-та сума

  a = {1, 2, 3, 4,  5,  6,  7,  8,  9,  10}
I_A = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55}

a[3] + a[4] + a[5] + a[6] + a[7] + a[8] = 3 + 4 + 5 + 6 + 7 + 8 = 33
I_A[8] - I_A[3-1] = 36 - 3 = 33

Сложността става О(M)

Домашно: Да се реши задачата в двумерното пространство. (вместо едномерен
масив да се въвежда матрица и
се търси сума на елементите от (i1,j1) до (i2,j2) )
*/