/*

Маймунката Gimpy попаднала в град Bananatown, който има правоъгълна форма (улиците са правоъгълна решетка) и
тя е в най-горния и най-ляв ъгъл на града. Тя разбрала, че има бананова плантация точно на другия край на града
(най-долу, най-дясно) и решила, че трябва да отиде да похапне на воля. Но преди да тръгне решила да провери
колко са възможните начини да отиде до мечтана точка като може да се движи само надолу и надясно.

Помогнете на Gimpy като напишете програма, която по зададен брой на улиците по хоризонтала и вертикала намира
броя на възможните различни пътища, по които може да стигне до бананите

Вход
На стандартния вход са зададени две числа N и M - броя на улиците по хоризонтала и вертикала.
Тъпо решение (1<=N,M<=15)
Нормално решение (1<=N,M<=1000)

Изход
На стандартния изход да се изведе едно число - броя на различните пътища.

Пример #1
	Вход
	3 4

	Изход
	10

     _ _ _
	|_|_|_|
	|_|_|_|

*/

#include <iostream>
#include <ctime>
using namespace std;

long long br;
int n,m;

void solve(int x, int y){
	if(x == n-1 && y == m-1) {
		br++; return;
	}

	if(x+1 < n) solve(x+1,y);
	if(y+1 < m) solve(x,y+1);
}

void solve2(){
	long long a[1024][1000];

	for(int i = 0; i < n; i++)
		a[i][0] = 1;
	for(int j = 0; j < m; j++)
		a[0][j] = 1;

	for(int i = 1; i < n; i++)
		for(int j = 1; j < m; j++)
			a[i][j] = a[i-1][j] + a[i][j-1];

	br = a[n-1][m-1];
}

int main(){

	cin>>n>>m;

	int start_s=clock();

	solve(0,0);
	//solve2();

	cout<<br<<endl;

	int stop_s=clock();
	cerr << "time: " << (stop_s-start_s)/double(CLOCKS_PER_SEC) << " sec" << endl;

	return 0;
}

/*
АНАЛИЗ:
Тъпото решение на задачата е с пълно изчерпване - обхождане на всички възмножни пътища и преброяването им.

Разумното решение е да се създаде матрица, която да помни възможните различни начини да се достигне до
кръстовище намиращо се на (i,j)-то място. Очевидно е, че до най-горните кръстовищата може да се стигне
само по един начин, защото можем да се движим само надясно. Същото може да се съобрази и за най-левите
кръстовища. Затова стойностите от матрицата се инициализират с единици. Като се вижда, че до кръстовище
(i,j) може да се стигне от кръстовище (i,j-1) и кръстовище (i-1,j), то различните начини да стигнем до
кръстовище (i,j) са сбора на възможните начини да стигнем до кръстовища (i,j-1) и (i-1,j). След това
правим обхождане на кръстовищата по хоризонтала и вертикала и отпечатваме стойността, която се е
получила в най-долното, най-дясно кръстовище.


ДОМАШНО: Имаме Матрица N*M ( N,M <1000 ) и всяка клетка съдържа даден брой ябълки. Трябва като тръгнем
от най-горе най-ляво и стигнем до най-долу най-дясно да вземем колкото се може повече ябълки, като
имаме право да се движим единствено надолу и надясно.

Тук очевидно подхода търсене с връщане не може да ни послужи, за това трябва да потърсим по умно решение
чрез мотода на Динамичното оптимиране. Първо трябва да забележим, че има само 2 начина да се стигне до
клетка: от ляво (освен ако не сме в първата колона) или от горе (освен ако не сме на първия ред). За да
намерим най-доброто решение за тази клетка, трябва да сме намерили решенията за всички клетки, от които
може да стигнем до тази клетка.

От горното наблюдение може да се извади следната релация:
	S[i][j]=A[i][j] + max(S[i-1][j], if i>0 ; S[i][j-1], if j>0)
(където i представлява реда и j колоната на таблицата, горния-ляв край с координати {0,0}; и A[i][j] броя
ябълки намиращи се в клетка i,j.

S[i][j] трябва да бъде пресмятано като тръгнем от ляво на дясно по всеки ред и сменяме редовете от горе надолу.
*/

